<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Concurrency-in-Go(1) | Ricardo Liu的博客</title><meta name="description" content="Concurrency-in-Go(1)"><meta name="keywords" content="Go 并发之道"><meta name="author" content="Ricardo Liu,lzxnotafraid@qq.com"><meta name="copyright" content="Ricardo Liu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Concurrency-in-Go(1)"><meta name="twitter:description" content="Concurrency-in-Go(1)"><meta name="twitter:image" content="https://images.pexels.com/photos/3511104/pexels-photo-3511104.jpeg?cs=srgb&amp;dl=pexels-3511104.jpg&amp;fm=jpg"><meta property="og:type" content="article"><meta property="og:title" content="Concurrency-in-Go(1)"><meta property="og:url" content="https://ricardoliu404.github.io/2020/03/19/Concurrency-in-Go(1)/"><meta property="og:site_name" content="Ricardo Liu的博客"><meta property="og:description" content="Concurrency-in-Go(1)"><meta property="og:image" content="https://images.pexels.com/photos/3511104/pexels-photo-3511104.jpeg?cs=srgb&amp;dl=pexels-3511104.jpg&amp;fm=jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://ricardoliu404.github.io/2020/03/19/Concurrency-in-Go(1)/"><link rel="next" title="桥接模式-Go" href="https://ricardoliu404.github.io/2020/03/03/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-Go/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://ricardoliu404.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Ricardo Liu的博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 测试</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 测试</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Goroutines"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Goroutines</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#启动Goroutine"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">启动Goroutine</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#创建连接点"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">创建连接点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Goroutine的变量引用"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Goroutine的变量引用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#衡量Goroutine的大小"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">衡量Goroutine的大小</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#sync包"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">sync包</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#WaitGroup"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">WaitGroup</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Mutex-amp-RWMutex"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Mutex &amp; RWMutex</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Mutex-互斥锁"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">Mutex 互斥锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#RWMutex-读写锁"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">RWMutex 读写锁</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Cond"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">Cond</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Once"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">Once</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Pool"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">Pool</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Goroutines"><span class="toc-number">1.</span> <span class="toc-text">Goroutines</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动Goroutine"><span class="toc-number">1.1.</span> <span class="toc-text">启动Goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建连接点"><span class="toc-number">1.2.</span> <span class="toc-text">创建连接点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine的变量引用"><span class="toc-number">1.3.</span> <span class="toc-text">Goroutine的变量引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#衡量Goroutine的大小"><span class="toc-number">1.4.</span> <span class="toc-text">衡量Goroutine的大小</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync包"><span class="toc-number">2.</span> <span class="toc-text">sync包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WaitGroup"><span class="toc-number">2.1.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutex-amp-RWMutex"><span class="toc-number">2.2.</span> <span class="toc-text">Mutex &amp; RWMutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex-互斥锁"><span class="toc-number">2.2.1.</span> <span class="toc-text">Mutex 互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RWMutex-读写锁"><span class="toc-number">2.2.2.</span> <span class="toc-text">RWMutex 读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cond"><span class="toc-number">2.3.</span> <span class="toc-text">Cond</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Once"><span class="toc-number">2.4.</span> <span class="toc-text">Once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pool"><span class="toc-number">2.5.</span> <span class="toc-text">Pool</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://images.pexels.com/photos/3511104/pexels-photo-3511104.jpeg?cs=srgb&amp;dl=pexels-3511104.jpg&amp;fm=jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Concurrency-in-Go(1)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-19<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-04-11</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%90%86%E8%AE%BA/">理论</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h1><p>Goroutine是Go中最基本的组织单位之一，每个Go程序最少拥有一个main goroutine，程序开始时自动创建。</p>
<h2 id="启动Goroutine"><a href="#启动Goroutine" class="headerlink" title="启动Goroutine"></a>启动Goroutine</h2><p>Go中使用go关键字放在函数钱来启动一个并发的函数，可以有以下三种形式：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> sayHello()    <span class="comment">// 1 调用一个函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Println(<span class="string">"anonymous"</span>)</span><br><span class="line">    }()              <span class="comment">// 2 调用匿名函数</span></span><br><span class="line">    <span class="keyword">go</span> sayGoodbye()  <span class="comment">// 3 调用一个函数变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sayGoodbye := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(<span class="string">"Goodbye"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>Go遵循称为fork-join模型的并发模型。fork这个词指的是在程序中的任何一点，它都可以将一个子执行的分支分离出来，以便与其父代同时运行。join这个词指的是这样一个事实，即在将来的某个时候，这些并发的执行分支将重新组合在一起。子分支重新加入的地方称为连接点。</p>
<h2 id="创建连接点"><a href="#创建连接点" class="headerlink" title="创建连接点"></a>创建连接点</h2><p>考虑上例中的注释1，在创建新的goroutine后被交给Go运行时安排执行，但并没有办法保证在main结束之前sayHello函数一定会被执行，因此我们需要让main goroutine等待或休眠一段时间，但这样并不意味着创建了一个连接点，只是一个竞态条件。为了创建一个连接点，我们可以使用sync包中的WaitGroup，在两个goroutine之间创建连接点，示例如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WatiGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> sayHello()</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>此时则一定会输出<code>hello</code>字样，此例中明确阻塞了main goroutine，直到sayHello goroutine运行结束，才会真正退出main goroutine，否则持续等待。（此处用法类似Java CountDownLatch）</p>
<h2 id="Goroutine的变量引用"><a href="#Goroutine的变量引用" class="headerlink" title="Goroutine的变量引用"></a>Goroutine的变量引用</h2><p>考察如下代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, greeting := <span class="keyword">range</span> []<span class="keyword">string</span>{<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>} {</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(greeting)</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></tbody></table></figure></div>

<p>事实上该程序的输出为</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></tbody></table></figure></div>

<p>同样是goroutine运行时环境已经发生改变的情况，在迭代字符串数组并为每一个切片启动一个goroutine的过程中，goroutine真正运行之前可能循环已经结束，但<code>greeting</code>变量保留了最后一次切片操作值的引用，即<code>good day</code>，因此会三次获得该值的输出。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, greeting := <span class="keyword">range</span> []<span class="keyword">string</span>{<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>} {</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(greeting <span class="keyword">string</span>)</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(greeting)</span><br><span class="line">    }(greeting)</span><br><span class="line">}</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></tbody></table></figure></div>

<p>上述写法则在每一次切片的时候向goroutine中传入了一个字符串副本，保证了三个字符串各出现一次（但是出现顺序依旧是不确定的）。</p>
<h2 id="衡量Goroutine的大小"><a href="#衡量Goroutine的大小" class="headerlink" title="衡量Goroutine的大小"></a>衡量Goroutine的大小</h2><p>官方FAQ中提到</p>
<blockquote>
<p>新建立一个goroutine有几千字节，这样的大小几乎总是够用的。 如果出现不够用的情况，运行时会自动增加（并缩小）用于存储堆栈的内存，从而允许许多goroutine存在适量的内存中。CPU开销平均每个函数调用大约三个廉价指令。 在相同的地址空间中创建数十万个goroutines是可以的。如果goroutines只是执行等同于线程的任务，那么系统资源的占用会更小。</p>
</blockquote>
<p>如下代码粗略估计goroutine的大小：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <- <span class="keyword">chan</span> <span class="keyword">interface</span>{}<span class="comment">// chan，用于接受数据</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> noop = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {      <span class="comment">// 这个goroutine不会退出，读取管道数据时阻塞，因此永远存在</span></span><br><span class="line">        wg.Done()        </span><br><span class="line">        <-c</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numGoroutines = <span class="number">1e4</span> <span class="comment">//goroutine数量，根据大数定律，渐进地逼近一个goroutine的大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	wg.Add(numGoroutines)</span><br><span class="line">	before := memConsumed()<span class="comment">//创建goroutine之前的内存消耗</span></span><br><span class="line">	<span class="keyword">for</span> i := numGoroutines; i > <span class="number">0</span>; i-- {</span><br><span class="line">		<span class="keyword">go</span> noop()</span><br><span class="line">	}</span><br><span class="line">	wg.Wait()</span><br><span class="line">	after := memConsumed()<span class="comment">//创建goroutine之后的内存消耗</span></span><br><span class="line">	fmt.Printf(<span class="string">"%.3fkb"</span>, <span class="keyword">float64</span>(after-before)/numGoroutines/<span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memConsumed</span><span class="params">()</span> <span class="title">uint64</span></span> {</span><br><span class="line">	runtime.GC()                <span class="comment">//执行一次垃圾回收</span></span><br><span class="line">	<span class="keyword">var</span> s runtime.MemStats      </span><br><span class="line">	runtime.ReadMemStats(&s)</span><br><span class="line">	<span class="keyword">return</span> s.Sys                <span class="comment">//返回当前系统内存状态</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>在Windows10 x64 & Go 1.14环境下，得到的数据为<code>8.692kb</code>。这个例子理想化地让我们了解了每个goroutine创建所需要的付出的空间代价。</p>
<p>接下来测试在一个线程上发送和接受消息所需的时间，此处构建一个类似Linux内核基准测试的Go例子，创建两个goroutine并在他们之间发送消息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkContextSwitch</span><span class="params">(b *testing.B)</span></span> {</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	begin := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> token <span class="keyword">struct</span>{}</span><br><span class="line">	sender := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<- begin<span class="comment">// 此处会阻塞，直到接收到数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span> ; i < b.N ; i ++ {</span><br><span class="line">			c <- token<span class="comment">// 接受发送者的数据，结构体不占空间，因此不会影响发送信息的时间</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	receiver := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<- begin<span class="comment">// 此处会阻塞，直到接收到数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span> ; i < b.N ; i ++ {</span><br><span class="line">			<- c<span class="comment">// 仅接受发送过来的数据，不作处理</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> sender()</span><br><span class="line">	<span class="keyword">go</span> receiver()</span><br><span class="line">	b.StartTimer()</span><br><span class="line">	<span class="built_in">close</span>(begin)</span><br><span class="line">	wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>结果如下，可见线程间切换速度为159ns/op</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkContextSwitch</span><br><span class="line">BenchmarkContextSwitch-8   	 9725066	       159 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure></div>

<h1 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h1><p>sync包包含对低级别内存访问同步最有用的并发原语。 如果你使用的是主要通过内存访问同步处理并发的语言，那么这些类型可能已经很熟悉了。Go与这些语言的区别在于，Go在内存访问同步基元的基础上构建了一组新的并发基元，并为使用者提供扩展的内容。 这些操作都有其用处——主要体现在小的作用域中，例如结构体。 你可以自行决定何时内存访问同步是最适当的。</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>若不关心并发操作的结果，或有其他方式收集结果，可以使用<code>WaitGroup</code>等待一组并发操作完成。<code>WaitGroup</code>类似于Java中的CountDownLatch，通过Add方法增加计数，通过Done方法减少计数。Wait方法会阻塞当前协程直到计数器归零。</p>
<p><strong>注意Add方法应在goroutine调用之前添加，否则无法保证Add方法在goroutine中的调用早于Wait的调用</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() </span><br><span class="line">	fmt.Println(<span class="string">"1st goroutine sleeping..."</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span>)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() </span><br><span class="line">	fmt.Println(<span class="string">"2nd goroutine sleeping..."</span>)</span><br><span class="line">	time.Sleep(<span class="number">2</span>)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">wg.Wait() </span><br><span class="line">fmt.Println(<span class="string">"All goroutines complete."</span>)</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="Mutex-amp-RWMutex"><a href="#Mutex-amp-RWMutex" class="headerlink" title="Mutex & RWMutex"></a>Mutex & RWMutex</h2><h3 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h3><p>Mutex提供了一种并发安全的方式来表示对共享资源访问的独占。下例有两个简单的goroutine，试图增加和减少一个公共值，病使用Mutex同步访问：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">    count ++</span><br><span class="line">    fmt.Println(<span class="string">"Incrementing: %d\n"</span>, count)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">    count --</span><br><span class="line">    fmt.Println(<span class="string">"Decrementing: %d\n"</span>, count)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arithmetic sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i <= <span class="number">5</span> ; i ++ {</span><br><span class="line">    arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">        increment()</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i <= <span class="number">5</span> ; i ++ {</span><br><span class="line">    arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">        decrement()</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arithmetic.Wait()</span><br><span class="line">fmt.Println(<span class="string">"Arithmetic complete."</span>)</span><br></pre></td></tr></tbody></table></figure></div>

<p>被锁定的部分时程序的性能瓶颈，进入和退出锁的成本较高，因此通常需要尽量减少锁定的范围。若多个并发进程之间共享的内存不是都要读和写的，可以考虑使用另一个类型的互斥锁：sync.RWMutex。</p>
<h3 id="RWMutex-读写锁"><a href="#RWMutex-读写锁" class="headerlink" title="RWMutex 读写锁"></a>RWMutex 读写锁</h3><p>RWMutex在控制方式上更加灵活，可以请求读锁，此时你可以读内存，除非有其他goroutine在进行写操作，也就是说，只要没有goroutine在进行写操作，可以允许任意数量的并发读。如下时一个实例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"text/tabwriter"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> producer = <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">5</span> ; i > <span class="number">0</span> ; i -- {</span><br><span class="line">		l.Lock()</span><br><span class="line">		l.Unlock()</span><br><span class="line">		time.Sleep(<span class="number">1</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">func</span><span class="params">(count <span class="keyword">int</span>, mutex, rwMutex sync.Locker)</span> <span class="title">time</span>.<span class="title">Duration</span></span> {</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(count + <span class="number">1</span>)</span><br><span class="line">	beginTestTime := time.Now()</span><br><span class="line">	<span class="keyword">go</span> producer(&wg, mutex)</span><br><span class="line">	<span class="keyword">for</span> i := count ; i > <span class="number">0</span> ; i -- {</span><br><span class="line">		<span class="keyword">go</span> observer(&wg, rwMutex)</span><br><span class="line">	}</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> time.Since(beginTestTime)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	tw := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">' '</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">defer</span> tw.Flush()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">	fmt.Fprintf(tw, <span class="string">"Readers\tRWMutex\tMutex\n"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i < <span class="number">20</span> ; i ++ {</span><br><span class="line">		count := <span class="keyword">int</span>(math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(i)))</span><br><span class="line">		fmt.Fprintf(</span><br><span class="line">			tw, <span class="string">"%d\t%v\t%v\n"</span>, count,</span><br><span class="line">			test(count, &m, m.RLocker()), test(count, &m, &m),</span><br><span class="line">			)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>本机运行环境为Ubunut 18.04 with Go 1.14，运行结果如下，可以观察到在某些情况下RWMutex耗时仍超过Mutex。（僵硬）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Readers  RWMutex       Mutex</span><br><span class="line">1        13.604µs      1.749µs</span><br><span class="line">2        2.063µs       1.675µs</span><br><span class="line">4        3.376µs       2.13µs</span><br><span class="line">8        9.271µs       5.18µs</span><br><span class="line">16       5.468µs       12.849µs</span><br><span class="line">32       18.164µs      29.581µs</span><br><span class="line">64       32.949µs      30.475µs</span><br><span class="line">128      30.385µs      32.923µs</span><br><span class="line">256      50.322µs      112.662µs</span><br><span class="line">512      98.378µs      117.562µs</span><br><span class="line">1024     248.239µs     244.162µs</span><br><span class="line">2048     428.428µs     421.438µs</span><br><span class="line">4096     735.572µs     859.512µs</span><br><span class="line">8192     1.645508ms    1.396318ms</span><br><span class="line">16384    3.436893ms    3.579149ms</span><br><span class="line">32768    6.182269ms    6.854283ms</span><br><span class="line">65536    12.855801ms   13.686491ms</span><br><span class="line">131072   25.55003ms    27.068042ms</span><br><span class="line">262144   54.767586ms   60.825475ms</span><br><span class="line">524288   103.354592ms  103.018981ms</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><blockquote>
<p>Cond实现了一个条件变量，用于等待或者宣布时间发生时goroutine的交汇点。</p>
</blockquote>
<p>有时需要在收到某个goroutine信号之前令自己处于等待状态，最初的暴力解决办法是使用无限循环<code>for conditionTrue() == false {/*巴拉巴拉*/}</code>，但是这样会消耗一个内核的所有周期。同事我们也可以用sleep的方法暂停当前协程，即<code>for conditionTrue() == false { time.Sleep(1 * time.Millisecond); /*巴拉巴拉*/}</code>，但是执行效率非常低，明确标示需要休眠多久，这样过长或过短都会浪费CPU时间。</p>
<p>此时我们即可考虑<code>Cond</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c := sync.NewCond(&sync.Mutex{})</span><br><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> conditionTrue() == <span class="literal">false</span> {</span><br><span class="line">	c.Wait()</span><br><span class="line">}</span><br><span class="line">c.L.UnLock()</span><br></pre></td></tr></tbody></table></figure></div>

<p>在该段代码中，首先实例化一个新的Cond，将互斥锁传入；接着锁定Cond中的Locker，因为在Wait调用时，此goroutine会被暂停并解锁该Locker；在循环中进入暂停状态，此处被阻塞，直到接收到通知；最后在循环外部解锁Locker。</p>
<p><strong>在这个例子里，调用<code>Wait</code>时不仅仅阻塞当前goroutine，同时会调用<code>c.L.Unlock()</code>，并在退出<code>Wait</code>时会调用<code>c.L.Lock()</code>。也就是说，在等待条件发生的过程中我们并非一直持有这个锁。</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">c := sync.NewCond(&sync.Mutex{})<span class="comment">//使用一个标准的sync.Mutex作为Locker来创建Cond</span></span><br><span class="line">queue := <span class="built_in">make</span>([]<span class="keyword">interface</span>{}, <span class="number">0</span>, <span class="number">10</span>)<span class="comment">//创建一个长度为零的切片。 由于我们知道最终会添加10个元素，因此我们将其容量设为10</span></span><br><span class="line"></span><br><span class="line">removeFromQueue := <span class="function"><span class="keyword">func</span><span class="params">(delay time.Duration)</span></span> {</span><br><span class="line">	time.Sleep(delay)</span><br><span class="line">	c.L.Lock()<span class="comment">//再次进入该并发条件下的关键部分，以修改与并发条件判断直接相关的数据</span></span><br><span class="line">	queue = queue[<span class="number">1</span>:]<span class="comment">//移除切片的头部并重新分配给第二个元素，这一步模拟了元素出列</span></span><br><span class="line">	fmt.Println(<span class="string">"Removed from Queue"</span>)</span><br><span class="line">	c.L.Unlock()<span class="comment">//退出操作关键部分，因为我们已经成功移除了一个元素</span></span><br><span class="line">	c.Signal()<span class="comment">//发出信号，通知处于等待状态的goroutine可以进行下一步了</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i < <span class="number">10</span> ; i ++ {</span><br><span class="line">	c.L.Lock()<span class="comment">//进入关键的部分前调用Lock来锁定c.L。</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">2</span> {<span class="comment">//在这里我们检查队列的长度，以确认什么时候需要等待。由于removeFromQueue是异步的，for不满足时才会跳出，而if做不到重复判断，这一点很重要。</span></span><br><span class="line">		c.Wait()<span class="comment">//调用Wait，这将阻塞main goroutine，直到接受到信号。</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"Adding to Queue"</span>)</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, <span class="keyword">struct</span>{}{})</span><br><span class="line">	<span class="keyword">go</span> removeFromQueue(<span class="number">1</span> * time.Second)<span class="comment">//创建一个新的goroutine，它会在1秒后将元素移出队列。</span></span><br><span class="line">	c.L.Unlock()<span class="comment">//这里我们退出条件的关键部分，因为我们已经成功加入了一个元素。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>上述代码片段输出为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Adding to queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue </span><br><span class="line">Removed from queue </span><br><span class="line">Adding to queue</span><br></pre></td></tr></tbody></table></figure></div>

<p>程序成功将所有十个元素添加到队列中，并有机会在最后两项出队之前退出。也会持续等待，直到至少有一个元素在放入另一个元素之前出列。<br><code>Signal</code>是<code>Cond</code>类型提供的两种通知方法之一，用于通知在等待调用上阻塞的goroutines条件已经被触发。另一种是<code>Broadcast</code>。在<code>Cond</code>内部，<code>runtime</code>维护了一个等待信号发送的goroutines的FIFO队列，<code>Signal</code>寻找等待时间最长的goroutine并通知，而<code>Broadcast</code>向所有处在等待状态的goroutines发送信号。</p>
<p>关于<code>Broadcast</code>可以有如下示例，该示例中创建一个带有按钮的程序，该程序注册任意数量的函数，点击按钮时运行这些函数，用<code>Broadcast</code>通知：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> {</span><br><span class="line">	<span class="comment">//定义一个Button类型，包含了sync.Cond指针类型的Clicked属性，这是goroutine接收通知的关键条件。</span></span><br><span class="line">	Clicked *sync.Cond</span><br><span class="line">}</span><br><span class="line">button := Button{Clicked: sync.NewCond(&sync.Mutex{})}</span><br><span class="line"></span><br><span class="line">subscribe := <span class="function"><span class="keyword">func</span><span class="params">(c *sync.Cond, fn <span class="keyword">func</span>()</span>)</span> { <span class="comment">//定义了简单的函数，允许我们注册函数来处理信号。每个注册的函数都在自己的goroutine上运行，并且在该goroutine不会退出，直到接收到通知。</span></span><br><span class="line">	<span class="keyword">var</span> tempwg sync.WaitGroup</span><br><span class="line">	tempwg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		tempwg.Done()</span><br><span class="line">		c.L.Lock()</span><br><span class="line">		<span class="keyword">defer</span> c.L.Unlock()</span><br><span class="line">		c.Wait()</span><br><span class="line">		fn()</span><br><span class="line">	}()</span><br><span class="line">	tempwg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//创建WaitGroup，等待所有子协程完成后再结束。</span></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">//注册了最大化窗口函数</span></span><br><span class="line">	fmt.Println(<span class="string">"Maximizing window."</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">})</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">//注册了对话框函数</span></span><br><span class="line">	fmt.Println(<span class="string">"Displaying annoying dialog box!"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">})</span><br><span class="line">subscribe(button.Clicked, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">//注册了鼠标点击函数</span></span><br><span class="line">	fmt.Println(<span class="string">"Mouse clicked."</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">button.Clicked.Broadcast() <span class="comment">//按钮在这里被点击</span></span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p><code>Once</code>确保了即使在不同goroutine上，调用<code>Do</code>传入的函数只执行一次。<br>例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span>				<span class="comment">// 一个计数变量</span></span><br><span class="line"></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {		<span class="comment">//函数，将计数变量自增1</span></span><br><span class="line">	count++</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once			<span class="comment">//定义Once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup		<span class="comment">//WaitGroup等待所有协程结束</span></span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">100</span>; i++ {	<span class="comment">//循环100次调用该方法</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		once.Do(increment)	<span class="comment">//将方法传入once.Do()中，指调用该函数</span></span><br><span class="line">	}()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"Count is %d\n"</span>, count)	<span class="comment">//将输出"Count is 1"</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>如果对<code>sync.Once.Do()</code>只计算Do被调用的次数，不关心调用的函数是什么，例如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { count++ }</span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { count-- }</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Count: %d\n"</span>, count)	<span class="comment">// 输出"Count: 1"</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>即once.Do()仅执行一次，后续的均被忽略。</p>
<p>在下例中，会发生什么样的情况呢？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> onceA, onceB sync.Once		</span><br><span class="line">	<span class="keyword">var</span> initB <span class="function"><span class="keyword">func</span><span class="params">()</span></span>				</span><br><span class="line">	initA := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {				</span><br><span class="line">		onceB.Do(initB)</span><br><span class="line">	}</span><br><span class="line">	initB = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {			<span class="comment">// 1</span></span><br><span class="line">		onceA.Do(initA)</span><br><span class="line">	}</span><br><span class="line">	onceA.Do(initA)				<span class="comment">// 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>该例子会出现死锁的情况：<code>2</code>处调用<code>initA</code>，此时<code>onceA</code>已经执行过一次。<code>initA</code>函数中调用<code>onceB</code>，执行<code>initB</code>，而<code>initB</code>中需要再次调用<code>onceA</code>执行<code>initA</code>，但<code>onceA</code>已经执行过一次，因此不会执行，至此<code>1</code>处无法执行，<code>2</code>处无法结束，输出的错误如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 2</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>池的概念是一种创建和提供固定数量可用对象的方式，通常用于约束创建资源昂贵的事务，例如数据库连接。</p>
<p><strong><code>sync.Pool</code>中保存的任何项都可能随时不做通知的释放掉，所以不适合用于像socket长连接或数据库连接池。</strong><br><strong><code>sync.Pool</code>可以安全的被多个线程同时使用</strong><br><strong><code>sync.Pool</code>主要用途是增加临时对象的重用率，减少GC负担</strong></p>
<p>Pool主要接口是Get方法，被调用时检查池中是否有可用的实例返回给调用者，如果没有，创建一个新成员变量，使用完后调用者用Put方法将实例放回池中。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myPool := &sync.Pool{</span><br><span class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>{} {</span><br><span class="line">		fmt.Println(<span class="string">"Creating new instance."</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">struct</span>{}{}</span><br><span class="line">	},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myPool.Get()             <span class="comment">//调用一次Get方法，执行New函数</span></span><br><span class="line">instance := myPool.Get() <span class="comment">//调用第二次Get方法，执行New函数</span></span><br><span class="line">myPool.Put(instance)     <span class="comment">//将第二次Get结果放回myPool中 剩下可用1</span></span><br><span class="line">myPool.Get()             <span class="comment">//调用第三次Get方法，无需执行New函数</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>处理临时变量时如果遇见一些大型结构体，可以使用Pool减少GC,例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> structR6 <span class="keyword">struct</span> {</span><br><span class="line">	B1 [<span class="number">10000000</span>]<span class="keyword">int</span>									<span class="comment">//大型数组</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> r6Pool = sync.Pool{</span><br><span class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>{} {</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(structR6)</span><br><span class="line">	},</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usePool</span><span class="params">()</span></span> {</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">100000000</span>; i++ {</span><br><span class="line">		sr6 := r6Pool.Get().(*structR6)</span><br><span class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">		r6Pool.Put(sr6)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"pool Used:"</span>, time.Since(startTime))</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">standard</span><span class="params">()</span></span> {</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">100000000</span>; i++ {</span><br><span class="line">		<span class="keyword">var</span> sr6 structR6</span><br><span class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"standard Used:"</span>, time.Since(startTime))</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	standard()</span><br><span class="line">	usePool()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>windows10 + Go 1.14的情况下，上述代码却出现了如下输出：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">standard Used: <span class="number">23.935</span>ms</span><br><span class="line">pool Used: <span class="number">1.3793458</span>s</span><br></pre></td></tr></tbody></table></figure></div>

<blockquote>
<p>emmmmmmmmmmmmmmmm </p>
<p align="right">--------------------留下了没技术了泪水</p></blockquote>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lzxnotafraid@qq.com">Ricardo Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ricardoliu404.github.io/2020/03/19/Concurrency-in-Go(1)/">https://ricardoliu404.github.io/2020/03/19/Concurrency-in-Go(1)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ricardoliu404.github.io">Ricardo Liu的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go-%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%81%93/">Go 并发之道    </a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/3511104/pexels-photo-3511104.jpeg?cs=srgb&amp;dl=pexels-3511104.jpg&amp;fm=jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/03/03/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-Go/"><img class="next_cover lazyload" data-src="https://images.unsplash.com/photo-1583165278902-412729c1e624?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>桥接模式-Go</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Ricardo Liu</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>